<비트 조작>

부울 연산자
- AND, OR, NOT은 기본 부울 연산자
- 연산들을 서로 결합하거나 조합해 다른 보조 연산을 만들어 낼 수 있음
- 대표적으로 XOR이 보조 연산에 해당하며, 기본 연산들의 조합으로 XOR을 구성할 수 있다.
EX) x = y = True
    (x and not y) or (not x and y)
    False
=> 그러나 XOR은 단순한 보조 연산을 뛰어 넘어 디지털 논리 게이트에서 매우 중요한 위치를 차지함

비트 연산자
- 부울연산자와 마찬가지로 비트 연산자도 동일하게 잘 작동
- 비트 연산자 NOT은 부울 변수에 적용하면 True는 1로 간주되어 -2가 된다.
= NOT은 2의 보수에서 1을 뺀 값과 같기 때문
=> 십진수로 표현할 때는 NOT x = - x - 1이 됨

2의 보수
- 컴퓨터가 음수를 저장하기 위해 일반적으로 취하는 여러 방법 중 하나
EX) 4비트로 숫자를 표현하는 예
  - 4비트로 표현 가능한 범위 = 0000 ~ 1111 총 16개. 양수만 저장한다면 0 ~ 15까지임
  - 절반을 쪼개서 음수 몫으로 할당하고 맨 앞 비트는 부호 비트로 사용 = 양수의 경우 0xxx를 사용하고 음수의 경우 1xxx를 사용함
- 숫자의 표현 범위는 -2^(n-1) ~ 2^(n-1) - 1
- 4비트로 2의 보수를 표현하려면 자릿수 제한 비트 연산에서 사용한 방법 MASK 사용
*MASK = 자릿수 만큼의 최댓값을 지닌 비트 마스트
- 파이썬에서는 임의 정밀도를 지원하기 때문에 내부적으로는 다소 복잡한 구조로 구현되어 있음
=> 부호는 별도 필드로 갖고 있으며, 비트 연산이 필요할 때만 2의 보수로 변환하는 작업을 함
=> 음수를 보여줄 때는 양의 정수를 표현하는 방식과 동일하게 하고, 앞에 부호만 덧붙여서 보여줌
EX) bin(-5) => '-0b101'

2의 보수 수학 연산
- 가산 역 연산이라고 부를 수 있음 = 양수를 음수로, 음수를 양수로 바꾸는 작엄
1) 비트 연산자 NOT은 2의 보수에서 1을 뺀 것
2) 2의 보수 수학 연산은 비트 연산자 NOT에서 1을 더한 것
EX) 0111의 2의 보수 연산은 1000 + 1 = 1001 / 1001의 비트 연산자 NOT은 0111 - 1 = 0110

비트 연산자 NOT
- 기존 비트 내에서 정확히 1을 0으로, 0을 1로 바꿔줌
