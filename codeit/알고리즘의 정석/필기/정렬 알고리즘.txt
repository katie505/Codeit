<정렬>
정렬 알고리즘
- 목록의 요소를 특정 순서대로 넣은 알고리즘
- 대개 숫자식 순서와 사전식 순서로 정렬
- 간단하고 익숙할 뿐만 아니라 여러모로 유용

1. 버블 정렬
- n번의 라운드로 이뤄져 있으며, 각 라운드마다 배열의 아이템을 한 번씩 쭉 모두 살펴본다
- 연달아 있는 아이템 2개의 순서가 잘못되어 있는 것을 발견하면, 두 아이템을 맞바꾼다
- 배열 전체를 쭉 살펴보는 것을 n번 하기 때문에 시간 복잡도는 항상 O(n^2)
- 이보다 더 비효율적일 수는 없으며 구현 가능한 가장 느린 정렬 알고리즘

2. 병합 정렬
- 분할 정복의 진수를 보여주는 알고리즘
- 최선과 최악 모두 O(nlogn)인 사실상 완전한 O(nlogn)으로 일정한 알고리즘
- 대부분의 경우 퀵 정렬보다는 느리지만 일정한 실행 속도뿐만 아니라 무엇보다도 안정 정렬이라는 점에서 여전히 상용 라이브러리에 많이 쓰이고 있음

3. 퀵 정렬
- 피벗을 기준으로 좌우를 나누는 특징 때문에 파티션 교환 정렬이라고도 불리움
- 분할 정복 알고리즘이며 여기에 피벗이라는 개념을 통해 피벗보다 작으면 왼쪽, 크면 오른쪽과 같은 방식으로 파티셔닝하면서 쪼개 나감
- 로무토 파티션 : 항상 맨 오른쪽의 피벗을 택하는 단순한 방식. 퀵 정렬 맨 처음에 등장하는 가장 기본적인 방식

4.
- 퀵 정렬은 이름처럼 매우 빠르며 굉장히 효율적인 알고리즘이지만 최악의 경우 O(n^2). 
- 만약 이미 정렬된 배열이 입력 값으로 들어왔다고 가정하면 이 경우 피벗은 계속 오른쪽에 위치하게 되므로 파티셔닝이 전혀 이뤄지지 않는다.
=> 이때 n번의 라운드에 걸쳐 결국 전체를 비교하기 때문에, 버블 정렬과 다를 바 없는 최악의 성능을 보이게 됨
- 항상 일정한 성능을 보이는 병합 정렬과 달리, 퀵 정렬은 이처럼 입력값에 따라 성능 편차가 심한 편

5. 안정 정렬 vs 불안정 정렬
- 안정 정렬 알고리즘 : 중복된 값을 입력 순서와 동일하게 정렬. 기존의 시간 순으로 정렬했던 순서는 지역명으로 재정렬하더라도 기존 순서가 그대로 유지된 상태에서 정렬이 이뤄짐
- 불안정 정렬 알고리즘 : 시간 순으로 정렬한 값을 지역명으로 재정렬하면 기존의 정렬 순서는 무시된 채 모두 뒤죽박죽 뒤섞이고 만다
=> 병합 정렬, 버블 정렬 = 안정 정렬
- 퀵 정렬의 또 다른 문제점은 안정 정렬이 아니라는 점. 즉, 불안정 정렬
