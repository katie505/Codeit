<힙>
- 두 개의 조건을 만족하는 트리
- 목적 : 정렬, 우선순위 큐 구현

조건
1) 형태 속성 : 힙은 완전 이진 트리다 / 높이 : log(n)
2) 힙 속성 : 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같다(최대 힙) / 작거나 같다(최소 힙)

정렬
- 정렬 알고리즘 : 데이터를 재배치하는 구체적인 방법
- 삽입 정렬, 선택 정렬, 퀵 정렬, 합병 정렬

힙 정렬(*오름차순 정렬)
- 힙 자료 구조를 이용해서 정렬하는 방법
1) 리스트를 힙으로 만들기 (heapify 호출)
2) root 와 마지막 노드 바꾸기
3) 바꾼 노드는 없는 노드 취급하기
4) 새로운 노드가 힙 속성을 지킬 수 있게 heapify 호출
5) 모든 인덱스를 돌 때까지 반복
* 내림 차순 정렬하기 위해서는 힙 속성(부모 노드가 자식 노드보다 작아야한다)을 반대로 바꾸고 똑같은 알고리즘 적용


힙 구현하기
- 완전 이진 트리는 동적 배열, 즉 파이썬 리스트로 구현

heapify 알고리즘
- 힙 속성을 지키지 않는 노드가 있을 때마다 그 노드가 맞는 위치를 찾을 때까지 맞는 위치에 재배치하는 알고리즘
- 특정 노드의 heapify 알고리즘 시간 복잡도 : O(log(n))
- 파라미터로 넘기는 노드가 힙에서 위치를 찾아간다
- 힙을 만드는데 걸리는 시간 : O(nlog(n))

힙 정렬 시간 복잡도
- 1번째 단계 : O(nlog(n))
- 2번째 단계 : O(1)
- 3번째 단계 : O(lg(n))
- 4번째 단계 : O(nlg(n))
=> O(nlog(n))
=> 선택 정렬과 삽입 정렬보다는 좋고, 합병 정렬과 퀵 정렬과는 비슷한 성능을 내는 정렬 방법

힙에 데이터 삽입하기
1) 힙의 마지막 인덱스에 데이터 삽입
2) 삽입한 데이터와 부모 노드의 데이터 비교 => 힙 속성 지키기
3) 새로 삽입한 노드가 제 위치를 찾을 때까지 반복
- 시간 복잡도
1) O(1)
2) O(1) + O(1) = O(1)
3) 최악의 경우 삽입한 데이터가 leaf 노드부터 시자해서 root 노드까지 올라가는 경우 : O(lg(n))
=> O(1+lg(n)) = O(lg(n))

힙에서 최고 우선순위 데이터 추출하기
1) root 노드와 마지막 노드를 서로 바꿔 주기
2) 마지막 노드의 데이터를 변수에 저장
3) 마지막 노드 삭제
4) root 노드에 heapify를 호출해서 망가진 힙 속성 고치기
5) 변수에 저장한 데이터 리턴
- 시간 복잡도
1) O(1)
2) O(1) + O(1)
3) O(lg(n))
4) O(1)
=> O(lg(n))

우선순위 큐
- 추상 자료형
- 데이터를 저장할 수 있다
- 저장한 데이터가 우선순위 순서대로 나온다
- 힙을 이용하면 효율적으로 구현할 수 있음

우선순위 큐 구현
1) 힙
2) 정렬된 동적 배열
- 데이터를 삽입하거나 추출해도, 동적 배열이 늘 정렬된 상태를 유지하게 하면 됨
3) 정렬된 이중 연결 리스트

- 정렬된 동적 배열이나 정렬된 이중 연결 리스트를 사용하면 데이터를 추출할 때 더 효율적
- 힙을 사용하면 데이터를 삽입할 때 더 효율적
=> 우선순위 큐는 상황에 따라 구현 방식이 다름




