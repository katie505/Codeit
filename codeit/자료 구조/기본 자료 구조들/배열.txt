<배열>
- 파이썬 리스트와 비슷
- 파이썬 언어는 C언어 기반, 리스트는 C배열 기반

파이썬 리스트 VS C배열
- 파이썬 리스트에서는 append 메소드를 쓰면 계속해서 요소를 추가할 수 있다
- C배열은 크기가 고정돼 있고, 각 요소를 수정할 수 있지만, 지우거나 삭제할 수 없음
- 파이썬 리스트에서는 다양한 타입의 값들을 담을 수 있지만, C배열에서는 같은 타입의 데이터만 담을 수 있음

정적 배열
- 일반적으로 배열은 정적배열
- 크기 고정(요소 수 제한)

동적 배열
- 크기 변함(요소 계속 추가 가능)
- 정적 배열로 만들어진 자료 구조 => 내부적으로 정적 배열 사용
- 정적 배열의 크기를 상황에 맞게 조절
- 파이썬 리스트가 바로 동적 배열
- 배열의 크기와 개발자가 사용하는 인덱스들의 범위 따로 관리

배열 vs 동적 배열
- 접근, 탐색 연산은 둘다 할 수 있음
- 삽입, 삭제 연산은 동적 배열만 할 수 있음. 배열은 크기가 고정되어 있기 때문에 삽입, 삭제 불가능
- 배열은 크기가 고정되어 있기 때문에 낭비하는 공간이 없지만, 동적 배열은 공간을 낭비할 수도 안 할 수도 있다.
- 동적배열에서 새로운 배열을 만들었을 때 낭비되는 공간이 가장 많음(총 요소 수 - 2) = O(n-2) = O(n)

추가 연산(append operation)
- 동적 배열의 가장 끝에 새로운 값을 추가
- 추가연산 실행 시간은 내부적으로 사용중인 배열의 상태에 따라 달라짐
1) 정적 배열에 남는 공간이 있을 때(최고의 경우) : O(1) => 자주 발생
- 새로운 인덱스에 데이터 저장
2) 정적 배열이 꽉 찼을 때(최악의 경우) : O(n) => 가끔 발생
- 기존 배열의 크기가 부족해서 더 큰 배열을 만들고, 기존 배열의 데이터들을 옮김
- 기존 배열에서 참조할 값은 더이상 없기 때문에 기존 배열은 자동으로 삭제됨

분할 상환 분석(Amortized Analysis
- 시간복잡도는 보통 최악의 상황을 말하는데 종종 비합리적일 때가 있음(EX) 추가연산) 이런 상황을 대비해서 시간복잡도를 다르게 계산하는 방법이 있음
- 그 중 하나가 '분할 상환 분석'
- 회계에서 사용하는 용어로 쉽게 생각하면 '할부'
- 시간복잡도로 최악의 상황을 말하는 것이 아닌 평균을 낸 것
- 분할 상환 분석을 한다고 꼭 시간 복잡도가 줄어드는 건 아니지만, 최악의 상황보다 분할 상환 분석을 한 시간 복잡도가 더 작다면, 분할 상환 분석을 한 시간 복잡도 사용

삽입 연산(insert operation)
- 아무 위치에나 새로운 데이터 추가
1) 정적 배열에 남는 공간이 있을 때 : O(n*1+1) = O(n)
2) 정적 배열이 꽉 찼을 때 : O(n+n+1) = O(n)
- 삽입 연산 시간 복잡도 = O(n)

삭제 연산
1) 아무 위치에 데이터를 삭제할 때는 원하는 위치 뒤에 있는 데이터를 옮겨 저장해야함 : O(n)
2) 가장 뒤에 있는 데이터를 삭제할 때는 다른 데이터를 옮길 필요 없음 : O(1)

* 삭제를 할 때에는 내부 배열의 크기를 줄여야함
- 동적 배열은 요소의 개수가 어느 정도 줄어들면 내부 배열의 크기도 적절히 줄여서 공간을 좀 더 효율적으로 사용
