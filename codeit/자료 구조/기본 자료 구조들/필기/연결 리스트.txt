<연결 리스트>
연결 리스트(Linked List)
- 데이터를 순서대로 저장해준다
- 동적 배열처럼 요소를 계속 추가할 수 있으며, 동적 배열보다 복잡함
- 노드라는 단위의 데이터를 저장하고 각 노드들을 순서대로 연결시켜서 만든 자료구조

노드<Node>
- 각 노드는 하나의 객체로 표현됨
- 두 개의 속성을 가짐 : data, next(다음 노드에 대한 reference)
- head 노드 : 첫 번째 노드
- 실제 메모리에서는 노드들이 순서대로 있는 것이 아니라 여기저기 흩어져 있음

연결 리스트 접근 연산
- 특정 위치에 있는 데이터에 접근할 수 있음
- 원하는 순서에 있는 노드를 리턴하는 연산
- 이 노드에서 데이터를 받아올 수 있고 기존 데이터를 다른 데이터로 바꿀 수 있음
- 헤드 노드에서 시작해서 다음 노드들을 하나씩 돌면서 원하는 위치의 노드에 접근
- 연결 리스트는 레퍼런스를 통해 순서를 저장하기 때문에 한번에 원하는 위치의 데이터에 접근할 수 없음
- 인덱스 x에 있는 노드에 접근하려면 head 노드에서 x번 이동해야함
- 시간복잡도 O(n)

연결 리스트 연산들 시간 복잡도
1) 접근 : 마지막 순서에 있는 노드에 접근해야 되는 최악의 경우에는 head 노드에서 총 n-1번 다음 노드로 가야됨.
=> 걸리는 시간은 n에 비례하기 때문에 O(n)

2) 탐색 : 접근과 마찬가지. O(n)

3) 삽입/삭제 : 삽입, 삭제할 인덱스의 주변 노드들에 연결된 레퍼런스만 수정. 
- 이 연산들이 실행되는데 걸리는 시간은 특정 값에 비례하지 않고 항상 일정
- 파라미터로 받는 이 노드가 어떤 순서에 있는 노드든 상관없이 걸리는 시간은 변하지 않음
- O(1)의 시간 복잡도를 갖음
- 하지만 현실적으로 생각하면 O(n)

<더블 연결 리스트>
- 앞 노드와 뒤 노드에 대한 레퍼런스를 모두 받음
- 단순 연결 리스트에서 prev 추가

더블 연결 리스트 연산들 시간 복잡도
1) 접근 & 탐색 : 단순 연결 리스트 접근과 탐색이랑 똑같음 => O(n)

2) 삽입 & 삭제 : 일정한 시간, O(1)

3) 현실적인 시간 복잡도 : 삽입, 삭제 연산을 하기 위해서는 특정 노드가 필요하고, 그 특정 노드를 접근 또는 탐색한 후에야 삽입과 삭제 가능
=> 그러므로 삽입&삭제의 시간복잡도 = O(n+1) = O(n)

4) 특수한 경우(head와 tail노드를 변수로 갖고 있을 때)
- 바로 접근할 수 있기 때문에 O(1)

* 연결 리스트를 사용해야 되는 상황에서 tail 노드를 많이 삭제해야 된다면 단순 연결 리스트보다 더블 연결 리스트를 사용하는 것이 더 효율적

<단순 vs 더블>
- 단순은 next만, 더블은 next, prev의 레퍼런스를 저장함
- 노드에 접근하는 방법이 다름 : 단순은 앞에 있는 노드들에 접근할 수 없지만, 더블은 앞, 뒤에 있는 노드들에 접근할 수 있음

- 추가적인 공간(실제 저장하려는 데이터를 제외한 다른 정보가 저장된 공간) : 연결 리스트에서는 다른 노드들에 대한 레퍼런스를 저장함
=> 단순 연결 리스트 노드는 실제 데이터와 다음 노드에 대한 레퍼런스 저장 : n-1개의 레퍼런스 저장 => O(n)
=> 더블 연결 리스트 노드는 실제 데이터와 다음 노드, 이전 노드에 대한 레퍼런스 저장 : 2n-2개의 레퍼런스 저장 => O(n)
** 단순 연결 리스트가 더블 연결 리스트에 비해 공간을 좀 더 효율적으로 사용할 수 있다.