Direct Access Table
- 배열 인덱스를 key로 이용해서 시간 효율적으로 데이터를 저장하고 가져오는 방식
- O(1)으로 key의 value에 접근 => 자칫하면 공간을 낭비할 수 있음

<해시 테이블>
- 해시 테이블 또는 해시 맵은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형을 구현하는 자료구조
- 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)
=> 데이터 양에 관계 없이 빠른 성능을 기대할 수 있다
- hash table
- 시간과 공간을 효율적으로 사용하는 자료 구조
- 해시 함수 + 배열
1) 고정된 크기의 배열을 만듦
2) 해시 함수를 이용해서 key를 원하는 범위의 자연수로 바꿈
3) 해시 함수 결과 값 인덱스에 key - value 쌍 저장

해시 함수
- 특정 값을 원하는 범위의 자연수로 바꿔주는 함수
- key가 아무리 커도 항상 원하는 범위 사이의 자연수로 바꿔줌
- 한 해시 테이블의 해시 함수는 결정론적이어야 됨
- 결과 해시값이 치우치지 않고 고르게 나옴
- 빨리 계산할 수 있어야 됨
- 데이터 간 순서 관계를 나타낼 수 없음
- 해시 함수 값 충돌의 최소화
- 사용할 키의 모든 정보를 이용하여 해싱

해싱
- 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것
- 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나
- 최적의 검색이 필요한 분야에 사용되며, 심볼 테이블 등의 자료 구조를 구현하기에도 적합

해시 함수 만들기
1) 나누기 방법
- 가장 직관적이면서 쉬운 방법
- 자연수 key를 해시 테이블의 크기로 나눈 나머지를 리턴하는 함수

2) 곱셈 방법
- 0과 1사이의 아무 값 a 정함 -> a를 key에 곱함 -> 정수 부분은 버리고 소수 부분만 남김 -> 남은 소수 부분에 배열의 크기 곱하고 정수 부분만 남김
- 항상 0보다 크거나 같고 배열의 크기보다 작은 숫자가 나옴

파이썬 hash 함수
- 파라미터로 받은 값을 특정 범위 안에 있는 정수가 아닌 아무 정수로만 바꿔주는 함수
- 데이터를 자신만의 고유한 정수 값으로 바꿔주는 함수
- 정수뿐만 아니라 다른 타입의 데이터도 가능
- 딕셔너리는 해시 테이블로 구현되어 있다.
=> 파이썬의 해시 테이블은 충돌 시 오픈 어드레싱 방식으로 구현되어 있음
- 한계 : 불변 타입 자료형에만 사용할 수 있음 : boolean, 정수, 소수, tuple, 문자열

해시 테이블 충돌
- 이미 데이터가 존재하는 인덱스에 새로운 데이터를 저장해야할 때
- 비둘기집 원리 : n개 아이템을 m개 컨테이너에 넣을 때, n > m이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리
=> 비둘기 집 원리에 따라 9개의 공간이 있는 곳에 10개의 아이템이 들어온다면 반드시 1번 이상은 충돌이 발생하게 됨

Chaining을 이용한 충돌 해결
- 충돌을 처리하는 방법 중 하나
- 배열 인덱스에 링크드 리스트 저장해서 충돌 해결
- 무한정 저장할 수 있음
- 링크드 리스트에 새로운 노드를 추가하는 식으로

*해시 테이블은 데이터의 순서 관계를 저장하지 않기 때문에 접근 연산이 없음
1) Chaining을 쓰는 해시 테이블 탐색 연산
- 원하는 key에 해당하는 value를 찾는 연산
- O(1 + 1 + n) = O(n)
2) 삽입 연산
- key - value 데이터 쌍을 저장 또는 수정
- O(1+1+n+1) = O(n)
3) 삭제 연산
- 원하는 key에 대한 key - value 데이터 쌍 삭제
- O(n)
** 모두 최악의 경우 O(n)이 걸리지만, 평균적으로 O(1)이 걸림
- O(n / m) : n = m일 경우. n : key - value 쌍의 수 / m : 배열의 크기

Open Addressing을 이용한 충돌 해결
- 충돌이 일어났을 때 다른 비어있는 인덱스에 데이터 저장하는 방법
- Chaining 방식과 달리, 전체 슬롯의 개수 이상은 저장할 수 없음
- 선형 탐사 : 충돌이 일어났을 때, 한 칸씩 다음 인덱스가 비었는지 확인
=> 꼭 선형 탐사를 사용해야 되는 건 아님
- 제곱 탐사 : 예를 들어 인덱스 10이라면 처음에는 1의 제곱 뒤에 있는 인덱스11, 그 다음에는 2의 제곱 뒤에 있는 인덱스15(= 11+4) 확인 이런식으로 계속 진행하는 방법
- 선형 탐사를 해왔다면 특정 해시값으로부터 한 곳에 몰려 있을 수도 있음
=> 계속해서 선형 탐사를 하면 주변의 공간들이 채워져 있을 수 있어서 충돌이 계속해서 발생할 확률이 높을 수 있음
=> 제곱을 이용하여 탐색하다보면 더 빠르게 빈 공간을 찾을 수 있음
- 제곱 탐사의 단점은 탐색하다보면 범위가 급격하게 커지기 때문에 공간을 많이 차지할 수 있음

1) 탐색 연산
- 선형 탐사를 이용해서 데이터 찾기
- 선형 탐사를 하다가 비어있는 인덱스를 찾게 되면 이 경우 key에 대한 데이터가 저장되어 있지 않다는 것

2) 삭제 연산
- 탐색 연산과 동일

*최악의 경우 시간 복잡도(해시 테이블이 사용하는 배열 거의 꽉 찼을 경우) : O(n)
*평균 시간 복잡도
- 해시 테이블 연산들을 분석할 때는 load factor 사용
- load factor a = n / m : 해시 테이블이 얼마나 차있는지를 나타내는 변수
=> load factor 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지 결정
=> 해시 함수가 키들을 잘 분산해 주는지를 말하는 효율성 측정에도 사용됨
=> 해시 테이블 안에 배열의 크기보다 많은 key - value 쌍을 저장할 수 없기 때문에 load factor은 항상 1보다 작다고 가정
- Open addressing을 사용하는 해시 테이블에서 평균적으로 탐사를 해야 되는 횟수(기댓값)은 1/1-a보다 작음
