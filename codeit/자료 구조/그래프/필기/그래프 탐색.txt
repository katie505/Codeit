<그래프 탐색>
그래프 탐색 : 하나의 시작점 노드에서 연결된 노드들을 모두 찾는 것
- 각 노드들을 어떤 순서로 탐색하는지에 따라 Breadth First Search, Depth First Search
- 순회 : 자료 구조안에 저장된 모든 데이터를 보는 것

BFS(Breadth FIrst Search) = 너비 우선 탐색 : 시작점에서 가까운 노드들을 탐색
- 그래프를 너비 우선적으로 탐색(수평적으로)
- 주로 큐로 구현, 그래프의 최단 경로를 구하는 문제 등에 사용됨
- DFS보다 쓰임새는 적다
- 재귀로 동작하지 않음
1) 시작 노드를 방문 표시 후, 큐에 넣음
2) 큐에 아무 노드가 없을 때까지:
	- 큐 가장 앞 노드를 꺼낸다
	- 꺼낸 노드에 인접한 노드들을 모두 보면서:
		- 처음 방문한 노드면:
			- 방문한 노드 표시를 해준다
			- 큐에 넣는다

- 시간 복잡도
1) 노드 전처리 : 모든 노드를 방문하지 않은 노드로 표시 = O(V)
2) 큐에 노드를 넣고 빼는데 걸리는 시간 : 큐는 데이터를 삽입하고 꺼내오는 연산들이 O(1) * 최대 V개의 노드 = O(V)
3) 큐에서 뺀 노드의 인접한 노드들을 도는데 걸리는 시간 : 모든 노드는 큐에 한 번만 들어가서 한 번만 나올 수 있음. 노드가 한 번 나올때마다 노드의 인접 리스트를 돌기 때문에 총 엣지 수 E에 비례하는 만큼 실행된다고 할 수 있음 = O(E)
=> 다 더하면 O(2V+E) = O(V+E)

DFS(Depth First Search) = 깊이 우선 탐색 
- 시작점에서 최대한 깊이 최대한 멀리 가는 탐색 방법(수직적으로)
- 주로 스택으로 구현하거나 재귀로 구현
** 코딩 테스트 시에도 '재귀 구현'이 더 선호되는 편
1) 재귀 DFS는 사전식 순서로 방문
2) 반복 DFS는 역순으로 방문. => 가장 마지막에 삽입된 노드부터 꺼내새ㅓ 반복하게 되고 인접 노드에서 가장 최근에 담긴 노드, 즉 가장 마지막부터 방문하기 때문
- 백트래킹을 통해 뛰어난 효용을 보임
(옅은 회색 = 스택에 들어있는 노드 /진한 회색 = 방문한 노드)
1) 시작 노드를 옅은 회색 표시 후, 스택에 넣음
2) 스택에 아무 노드가 없을 때까지:
	- 스택 가장 위 노드를 꺼낸다
	- 노드를 방문 표시한다
	- 인접한 노드들을 모두 보면서:
		- 처음 방문하거나 스택에 없는 노드면:
			- 옅은 회색 표시를 해준다
			- 스택에 넣어준다
- 시간 복잡도
1) 노드 전처리 : 모든 노드를 노란색 노드로 표시 = O(V)
2) 스택에 노드를 넣고 빼는 데 걸리는 시간 : 스택은 데이터를 삽입, 추출하는데 O(1) * 최대 V개의 노드 = O(V)
3) 스택에서 뺀 노드들의 인접한 노드들을 도는데 걸리는 시간 : BFS와 동일 : O(E)
=> O(2V+E) = O(V+E)

백트래킹(Backtracking)
- 해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기(백트랙)해 정답을 찾아나가는 범용적인 알고리즘으로 제약 충족 문제에 특히 유용
- DFS와 같은 방식으로 탐색하는 모든 방법. DFS는 백트래킹의 골격을 이루는 알고리즘
- 주로 재귀로 구현, 알고리즘마다 DFS 변형이 조금씩 일어나지만 기본적으로 모두 DFS의 범주에 속함

제약 충족 문제
- 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제
- 인공지능이나 경영 과학 분야에서 심도 있게 연구되고 있으며, 합리적인 시간 내에 문제를 풀어내기 위해 휴리스틱과 조합 탐색 같은 개념을 함께 결합해 문제 풀이
- 스도쿠, 십자말 풀이, 8퀸 문제, 4색 문제 같은 퍼즐 문제 / 배낭 문제, 문자열 파싱, 조합 최적화 문제 등
